using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml;
using System.Xml.Serialization;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Editing;
using Microsoft.CodeAnalysis.Formatting;

namespace CodeGeneratorDriver
{
    internal class Program
    {

        /*List<SyntaxNode> declerations = new List<SyntaxNode>();

            declerations.AddRange(SharedGeneratorion.UsingDirectives());

            declerations.Add(generator.NamespaceDeclaration(options.NameSpace + ".Internal",
            ((ClassDeclarationSyntax) ).AddAttributeLists(
                SharedGeneratorion.AutoGenerated(generator)
                )));*/
        public static void Main(string[] args)
        {
            Console.WriteLine("Code generator started with arguments " +
                              string.Join(", ", args.Select(x => '"' + x + '"')));

            if(args.Length != 5)
                Environment.Exit(-1);

            string xmlPath = args[0];
            string nodesSavePath = args[1];          //Where we want the red nodes
            string factorySavePath = args[2];        //Where we want the factory
            string internalNodesSavePath = args[3];  //Where we want the green ones
            string visitorsSavePath = args[4];       //Where we want the visitors

            Model model = ReadDefinition(xmlPath);

            Workspace workspace = new AdhocWorkspace();
            SyntaxGenerator generator = SyntaxGenerator.GetGenerator(workspace, LanguageNames.CSharp);

            List<SyntaxNode> redNodes = new List<SyntaxNode>();

            List<SyntaxNode> factoryMethods = new List<SyntaxNode>();

            List<SyntaxNode> greenNodes = new List<SyntaxNode>();

            List<SyntaxNode> visitors = new List<SyntaxNode> {
                new VoidVisitorGenerator(generator, model).CreateVisitor("SyntaxVisitor"),
                new SimpleTVisitorGenerator(generator, model).CreateVisitor("SyntaxVisitor"),

                new ComplexTVisitorGenerator(
                    generator,
                    model,
                    SyntaxFactory.ParseTypeName("SyntaxVisitor<T>")
                ).CreateVisitor("SimpleSyntaxVisitor"),

                new SyntaxRewriterGenerator(
                        generator,
                        model,
                        SyntaxFactory.ParseTypeName($"SyntaxVisitor<{SharedGeneratorion.RedNodeName(model.Options.BaseName)}>")
                ).CreateVisitor("SyntaxRewriter")
            };

            foreach (Node node in model.Nodes)
            {
                if(node.Manual) continue;

                redNodes.Add(RedNodeGenerator.CreateRedNode(generator, node, model.Options));
                greenNodes.Add(GreenNodeGenerator.CreateGreenNode(generator, node, model.Options));

                if(node.Abstract) continue;
                factoryMethods.AddRange(Factory.CreateFactoryFor(generator, node, model.Options));
            }

            //Every red node is partial and has 3 parts: The node itself, a static factory node, and the internal green node.
            var factoryMethodsPartOfRedNode = new[]
            {
                generator.ClassDeclaration(
                    SharedGeneratorion.RedNodeName(model.Options.BaseName),
                    null,
                    Accessibility.Public,
                    DeclarationModifiers.Partial,
                    null, null,
                    factoryMethods
                )
            };

            var greenNodesPartOfRedNodes = new[]
            {
                generator.ClassDeclaration(
                    SharedGeneratorion.RedNodeName(model.Options.BaseName),
                    null,
                    Accessibility.Public,
                    DeclarationModifiers.Partial,
                    null, null,
                    greenNodes
                )
            };

            //Generated enum for all NodeTypes
            redNodes.Add(GeneratedTypeEnum(generator, model.Nodes));

            Save(Finalize(generator, model.Options.NameSpace, workspace, redNodes), nodesSavePath);

            Save(Finalize(generator, model.Options.NameSpace, workspace, visitors), visitorsSavePath);

            Save(Finalize(generator, model.Options.NameSpace, workspace, factoryMethodsPartOfRedNode), factorySavePath);

            Save(Finalize(generator, model.Options.NameSpace, workspace, greenNodesPartOfRedNodes), internalNodesSavePath);

            Console.WriteLine("Finished");
        }

        private static SyntaxNode GeneratedTypeEnum(SyntaxGenerator generator, Node[] nodes)
        {
            return generator.EnumDeclaration("NodeType", Accessibility.Public, DeclarationModifiers.None,
                nodes.Select(x => generator.EnumMember(x.Name.NonGenericPart()))
            );
        }

        private static SyntaxNode Finalize(SyntaxGenerator generator, string nameSpace, Workspace workspace, IEnumerable<SyntaxNode> original)
        {
            var cu = generator.CompilationUnit(new[]
                {
                    //TODO: Add comment "this was auto-generated do not touch"
                    generator.NamespaceImportDeclaration("System"),
                    generator.NamespaceImportDeclaration("System.Collections.Generic"),
                    generator.NamespaceImportDeclaration("System.Linq"),
                    generator.NamespaceImportDeclaration("Antlr4.Runtime.Misc"),
                    generator.NamespaceImportDeclaration("libcompiler.Scope"),
                    generator.NamespaceImportDeclaration("libcompiler.TypeSystem"),
                    generator.NamespaceDeclaration(nameSpace, original)
                }
            );

            return Formatter.Format(cu, workspace);
        }

        /// <summary>
        /// Save to file
        /// </summary>
        private static void Save(SyntaxNode tree, string path)
        {
            File.WriteAllText(path, tree.ToString());
        }

        private static Model ReadDefinition(string path)
        {
            var nodes = (Model)new XmlSerializer(typeof(Model)).Deserialize(XmlReader.Create(File.OpenRead(path)));

            Dictionary<string, Node> dictionary = nodes.Nodes.ToDictionary(x => x.Name.Split('\'')[0]);

            foreach (Node node in nodes.Nodes)
            {
                if(node.BaseClass == null && node.Name == nodes.Options.BaseName) continue;

                node.BaseNode = dictionary[node.BaseClass.Split('\'')[0]];
            }

            //Don't take the top level node, too much special stuff so implemented in hand anyway
            nodes.Nodes = nodes.Nodes.Where(node => node.BaseNode != null).ToArray();

            return nodes;
        }
    }
}
 