using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml;
using System.Xml.Serialization;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Editing;
using Microsoft.CodeAnalysis.Formatting;

namespace CodeGeneratorDriver
{
    internal class Program
    {

        /*List<SyntaxNode> declerations = new List<SyntaxNode>();

            declerations.AddRange(SharedGeneratorion.UsingDirectives());

            declerations.Add(generator.NamespaceDeclaration(options.NameSpace + ".Internal",
            ((ClassDeclarationSyntax) ).AddAttributeLists(
                SharedGeneratorion.AutoGenerated(generator)
                )));*/
        public static void Main(string[] args)
        {
            if(args.Length != 5)
                Environment.Exit(-1);

            string xmlPath = args[0];
            string nodes = args[1];
            string factory = args[2];
            string @internal = args[3];
            string visitor = args[4];


            SyntaxGeneration syntaxGeneration = ReadDefinition(xmlPath);
            Workspace workspace = new AdhocWorkspace();
            SyntaxGenerator generator = SyntaxGenerator.GetGenerator(workspace, LanguageNames.CSharp);

            List<SyntaxNode> redNodes = new List<SyntaxNode>();
            List<SyntaxNode> factoryMethods = new List<SyntaxNode>();
            List<SyntaxNode> greenNodes = new List<SyntaxNode>();
            List<SyntaxNode> visitors = new List<SyntaxNode>()
            {
                new VoidVisitorGenerator(generator, syntaxGeneration).CreateVisitor("SyntaxVisitor"),
                new SimpleTVisitorGenerator(generator, syntaxGeneration).CreateVisitor("SyntaxVisitor"),
                new ComplexTVisitorGenerator(generator, syntaxGeneration,
                    SyntaxFactory.ParseTypeName("SyntaxVisitor<T>")).CreateVisitor("SimpleSyntaxVisitor"),
                new SyntaxRewriterGenerator(generator, syntaxGeneration,
                        SyntaxFactory.ParseTypeName($"SyntaxVisitor<{SharedGeneratorion.RedNodeName(syntaxGeneration.Options.BaseName)}>"))
                    .CreateVisitor("SyntaxRewriter")
            };

            foreach (Node node in syntaxGeneration.Node)
            {
                redNodes.Add(RedNodeGenerator.CreateRedNode(generator, node, syntaxGeneration.Options));
                greenNodes.Add(GreenNodeGenerator.CreateGreenNode(generator, node, syntaxGeneration.Options));
                factoryMethods.AddRange(Factory.CreateFactoryFor(generator, node, syntaxGeneration.Options));
                //TODO: Factory
            }

            Save(Formatter.Format(generator.NamespaceDeclaration(syntaxGeneration.Options.NameSpace, redNodes), workspace), nodes);
            Save(Formatter.Format(generator.NamespaceDeclaration(syntaxGeneration.Options.NameSpace, visitors), workspace), visitor);

            Save(
                Formatter.Format(
                    generator.NamespaceDeclaration(syntaxGeneration.Options.NameSpace,
                        generator.ClassDeclaration(syntaxGeneration.Options.BaseName, null, Accessibility.Public,
                            DeclarationModifiers.Partial, null, null, members: factoryMethods)), workspace), factory);
            Save(
                Formatter.Format(
                    generator.NamespaceDeclaration(syntaxGeneration.Options.NameSpace,
                        generator.ClassDeclaration(syntaxGeneration.Options.BaseName, null, Accessibility.Public,
                            DeclarationModifiers.Partial, null, null, members: greenNodes)), workspace), @internal);
            Console.ReadLine();

        }

        private static void Save(SyntaxNode tree, string path)
        {
            //TODO: Fix comment

            File.WriteAllText(path, tree.ToString());
        }

        private static SyntaxGeneration ReadDefinition(string path)
        {
            var nodes = (SyntaxGeneration)new XmlSerializer(typeof(SyntaxGeneration)).Deserialize(XmlReader.Create(File.OpenRead(path)));

            var dictionary = nodes.Node.ToDictionary(x => x.Name);

            foreach (Node node in nodes.Node)
            {
                if(node.BaseClass == null && node.Name == nodes.Options.BaseName) continue;

                node.BaseNode = dictionary[node.BaseClass];
            }

            //Don't take the top level node, too much special stuff so implemented in hand anyway
            nodes.Node = nodes.Node.Where(node => node.BaseNode != null).ToArray();

            return nodes;
        }
    }
}
 