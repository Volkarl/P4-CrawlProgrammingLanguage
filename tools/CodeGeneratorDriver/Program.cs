using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml;
using System.Xml.Serialization;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Editing;
using Microsoft.CodeAnalysis.Formatting;

namespace CodeGeneratorDriver
{
    internal class Program
    {

        /*List<SyntaxNode> declerations = new List<SyntaxNode>();

            declerations.AddRange(SharedGeneratorion.UsingDirectives());

            declerations.Add(generator.NamespaceDeclaration(options.NameSpace + ".Internal",
            ((ClassDeclarationSyntax) ).AddAttributeLists(
                SharedGeneratorion.AutoGenerated(generator)
                )));*/
        public static void Main(string[] args)
        {
            Console.WriteLine("Code generator started with arguments " +
                              string.Join(", ", args.Select(x => '"' + x + '"')));

            if(args.Length != 5)
                Environment.Exit(-1);

            string xmlPath = args[0];
            string nodes = args[1];
            string factory = args[2];
            string @internal = args[3];
            string visitor = args[4];


            Model model = ReadDefinition(xmlPath);

            Workspace workspace = new AdhocWorkspace();
            SyntaxGenerator generator = SyntaxGenerator.GetGenerator(workspace, LanguageNames.CSharp);

            List<SyntaxNode> redNodes = new List<SyntaxNode>();
            List<SyntaxNode> factoryMethods = new List<SyntaxNode>();
            List<SyntaxNode> greenNodes = new List<SyntaxNode>();
            List<SyntaxNode> visitors = new List<SyntaxNode>()
            {
                new VoidVisitorGenerator(generator, model).CreateVisitor("SyntaxVisitor"),
                new SimpleTVisitorGenerator(generator, model).CreateVisitor("SyntaxVisitor"),
                new ComplexTVisitorGenerator(generator, model,
                    SyntaxFactory.ParseTypeName("SyntaxVisitor<T>")).CreateVisitor("SimpleSyntaxVisitor"),


                new SyntaxRewriterGenerator(generator, model,
                        SyntaxFactory.ParseTypeName($"SyntaxVisitor<{SharedGeneratorion.RedNodeName(model.Options.BaseName)}>"))
                    .CreateVisitor("SyntaxRewriter")
            };

            foreach (Node node in model.Node)
            {
                if(node.Manual) continue;

                redNodes.Add(RedNodeGenerator.CreateRedNode(generator, node, model.Options));
                greenNodes.Add(GreenNodeGenerator.CreateGreenNode(generator, node, model.Options));

                if(node.Abstract) continue;
                factoryMethods.AddRange(Factory.CreateFactoryFor(generator, node, model.Options));
            }

            //Generated enum for all NodeTypes
            redNodes.Add(GeneratedTypeEnum(generator, model.Node));


            Save(Patch(generator, model.Options.NameSpace, workspace, redNodes), nodes);

            Save(Patch(generator, model.Options.NameSpace, workspace, visitors), visitor);

            Save(Patch(generator, model.Options.NameSpace, workspace, new[]
            {
                generator.ClassDeclaration(SharedGeneratorion.RedNodeName(model.Options.BaseName), null, Accessibility.Public,
                    DeclarationModifiers.Partial, null, null, members: factoryMethods)
            }), factory);

            Save(Patch(generator, model.Options.NameSpace, workspace, new[]
            {
                generator.ClassDeclaration(SharedGeneratorion.RedNodeName(model.Options.BaseName), null, Accessibility.Public,
                    DeclarationModifiers.Partial, null, null, members: greenNodes)
            }), @internal);

            Console.WriteLine("Finished");

        }

        private static SyntaxNode GeneratedTypeEnum(SyntaxGenerator generator, Node[] nodes)
        {
            return generator.EnumDeclaration("NodeType", Accessibility.Public, DeclarationModifiers.None,
                nodes.Select(x => generator.EnumMember(x.Name.NonGenericPart()))
            );
        }

        private static SyntaxNode Patch(SyntaxGenerator generator, string nameSpace, Workspace workspace, IEnumerable<SyntaxNode> original)
        {
            var cu = generator.CompilationUnit(new[]
            {
                generator.NamespaceImportDeclaration("System"),
                generator.NamespaceImportDeclaration("System.Collections.Generic"),
                generator.NamespaceImportDeclaration("System.Linq"),
                generator.NamespaceImportDeclaration("Antlr4.Runtime.Misc"),
                generator.NamespaceImportDeclaration("libcompiler.TypeSystem"),
                generator.NamespaceDeclaration(nameSpace, original)
            });


            return Formatter.Format(cu, workspace);
        }

        private static void Save(SyntaxNode tree, string path)
        {
            //TODO: Fix comment

            File.WriteAllText(path, tree.ToString());
        }

        private static Model ReadDefinition(string path)
        {
            var nodes = (Model)new XmlSerializer(typeof(Model)).Deserialize(XmlReader.Create(File.OpenRead(path)));

            var dictionary = nodes.Node.ToDictionary(x => x.Name.Split('\'')[0]);

            foreach (Node node in nodes.Node)
            {
                if(node.BaseClass == null && node.Name == nodes.Options.BaseName) continue;

                node.BaseNode = dictionary[node.BaseClass.Split('\'')[0]];
            }

            //Don't take the top level node, too much special stuff so implemented in hand anyway
            nodes.Node = nodes.Node.Where(node => node.BaseNode != null).ToArray();

            return nodes;
        }
    }
}
 