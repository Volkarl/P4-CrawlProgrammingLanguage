using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Editing;

namespace CodeGeneratorDriver
{
    /// <summary>
    /// Useful static methods shared across generation-part of our code.
    /// </summary>
    public static class SharedGeneratorion
    {
        public static IEnumerable<SyntaxNode> UsingDirectives()
        {
            yield return SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System"));
            yield return SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.Text"));
        }



        public static SyntaxNode GetOnlyAccessor(string name, TypeSyntax type)
        {
            return SyntaxFactory.PropertyDeclaration(

                    type, name)
                .WithAccessorList(
                    SyntaxFactory.AccessorList(
                        SyntaxFactory.List(
                            new AccessorDeclarationSyntax[1]
                            {
                                SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                                    .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken))
                            }
                        )))
                .WithModifiers(SyntaxTokenList.Create(SyntaxFactory.Token(SyntaxKind.PublicKeyword)));
        }

        public static void AddLineBreak(List<SyntaxNode> classContents)
        {
            if (classContents.Count == 0) return;
            SyntaxNode lastNode = classContents.Last();
            lastNode = lastNode.WithTrailingTrivia(SyntaxFactory.CarriageReturnLineFeed, SyntaxFactory.CarriageReturnLineFeed);
            classContents[classContents.Count - 1] = lastNode;
        }

        public static string GreenNodeName(string name)
        {
            string[] parts = name.Split('\'');
            if (parts.Length == 2)
            {
                return $"Green{parts[0]}Node<{parts[1]}Node>";
            }

            return $"Green{name}Node";
        }

        /// <summary>
        /// Get name of red node from the general name.
        /// </summary>
        /// <param name="name">The name of a node, as written in the xml</param>
        /// <returns>The name of that type's red node</returns>
        public static string RedNodeName(string name)
        {
            string[] parts = name.Split('\'');
            if (parts.Length == 2)
            {
                return $"{parts[0]}Node<{parts[1]}Node>";
            }

            return $"{name}Node";
        }

        public static AttributeListSyntax AutoGenerated(SyntaxGenerator generator)
        {
            return (AttributeListSyntax) generator.Attribute("System.CodeDom.Compiler.GeneratedCode",
                generator.LiteralExpression("CodeGeneratorDriver"), generator.LiteralExpression("v0.1"));

        }
    }
}